<!DOCTYPE HTML>
<html manifest="">

<head th:insert="~{head}"></head>
	<style>
		.grid-container {
			display: grid;
			grid-template-columns: repeat(5, 120px); /* Fixed width for columns */
			grid-template-rows: repeat(15, 40px); /* Fixed height for rows */
			gap: 5px;
			padding: 10px;
			background-color: #f4f4f4;
			border-radius: 4px;
			width: fit-content; /* Adjust grid width to fit content */
			margin: auto; /* Center the grid */
		}
		.grid-cell {
			background-color: #fff;
			border: 1px solid #ddd;
			border-radius: 4px;
			padding: 2px;
			display: flex;
			align-items: center;
			justify-content: center;
			position: relative; /* For positioning the cell code and autocomplete */
			transition: background-color 0.5s ease;
		}
		.grid-cell.occupied {
			background-color: #dff0d8; /* success color for occupied cells */
		}
		.grid-cell.focused {
			border: 1px solid #007bff; /* AdminLTE blue for focused state */
		}
		.grid-cell.update-success {
			background-color: #5cb85c;
		}
		.grid-cell.update-error {
			background-color: #d9534f;
		}
		.grid-cell-label {
			position: absolute;
			top: 2px;
			left: 2px;
			font-size: 8px;
			color: #aaa;
		}
		.grid-cell input {
			width: calc(100% - 4px); /* Full width minus padding */
			height: calc(100% - 4px); /* Full height minus padding */
			border: none;
			text-align: center;
			font-size: 12px;
			background-color: transparent; /* Match cell background */
			padding-top: 10px; /* Make space for label */
			text-transform: uppercase;
		}
		.grid-cell input:focus {
			outline: none; /* Remove the default outline */
		}
		.autocomplete-results {
			position: absolute;
			top: 100%; /* Position below the input */
			left: 0;
			right: 0;
			background-color: #fff;
			border: 1px solid #ddd;
			border-top: none;
			z-index: 1000;
			max-height: 150px;
			overflow-y: auto;
		}
		.autocomplete-item {
			padding: 8px;
			cursor: pointer;
			font-size: 12px;
		}
		.autocomplete-item:hover {
			background-color: #f0f0f0;
		}
		.cell-spinner {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			width: 20px;
			height: 20px;
			border: 2px solid #f3f3f3;
			border-top: 2px solid #3498db;
			border-radius: 50%;
			animation: spin 1s linear infinite;
			z-index: 10;
		}
		@keyframes spin {
			0% { transform: translate(-50%, -50%) rotate(0deg); }
			100% { transform: translate(-50%, -50%) rotate(360deg); }
		}
	</style>
</head>

<body class="skin-black layout-top-nav" style="height: auto; min-height: 100%;">

	<div class="wrapper" style="height: auto; min-height: 100%;">
		
		<header class="main-header" th:insert="~{navbar}"></header>

		<div class="content-wrapper" style="position: relative; min-height: 600px;">
		    <section class="content">
				<div class="box box-primary">
					<div class="box-header with-border">
						<h3 class="box-title">Expositores</h3>
						<div class="box-tools pull-right">
							<a href="#" id="export-pdf-button" class="btn btn-default btn-sm" title="Exportar para PDF"><i class="fa fa-file-pdf-o"></i></a>
						</div>
					</div>
					<!-- New div for display buttons -->
					<div id="display-selector-row" class="row">
						<div class="col-xs-12 text-center">
							<div id="display-buttons-container" class="btn-group" style="margin-bottom: 10px;">
								<!-- Display buttons will be inserted here -->
							</div>
						</div>
					</div>
					<div class="box-body" id="display-grid-container" style="min-height: 500px;">
						<!-- Display grid will be rendered here -->
					</div>
					<div id="display-footer" class="box-footer">
						Selecione um expositor para visualizar as células.
					</div>
				</div>
		    </section>
		</div>
		<footer th:insert="~{footer}" class="main-footer">
		</footer>

	</div>

	<script src="/adminlte/bower_components/jquery/dist/jquery.min.js"></script>
	<script	src="/adminlte/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
	<script src="/adminlte/dist/js/adminlte.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
		
	<script>
		$(document).ready(function() {
			const displayButtonsContainer = document.getElementById('display-buttons-container');
			const displayGridContainer = document.getElementById('display-grid-container');
			const displayFooter = document.getElementById('display-footer');
			let currentDisplayId = null;

			function fetchDisplays() {
				fetch('/api/displays')
					.then(response => response.json())
					.then(displays => {
						if (displays && displays.length > 0) {
							renderDisplayButtons(displays);
							fetchCells(displays[0].id);
							setTimeout(() => {
								const firstButton = displayButtonsContainer.querySelector('button');
								if (firstButton) {
									firstButton.classList.add('btn-primary');
									firstButton.classList.remove('btn-default');
								}
							}, 0);
						}
					});
			}

			function fetchCells(displayId) {
				currentDisplayId = displayId; // Store current display ID
				const exportButton = document.getElementById('export-pdf-button');
				if (exportButton) {
					exportButton.href = `/api/displays/${displayId}/export/pdf`;
				}
				displayGridContainer.innerHTML = '<div style="text-align:center; padding: 50px;"><i class="fa fa-spinner fa-spin fa-3x"></i></div>';
				fetch(`/api/displays/${displayId}/cells`)
					.then(response => response.json())
					.then(cells => {
						renderGrid(cells);
					});
			}

			function updateOccupancyCount() {
				const grid = displayGridContainer.querySelector('.grid-container');
				if (!grid) return;

				const totalCells = grid.children.length;
				const occupiedCount = grid.querySelectorAll('.grid-cell.occupied').length;
				const freeCells = totalCells - occupiedCount;
				displayFooter.textContent = `Exibindo ${totalCells} células. Ocupadas: ${occupiedCount}. Livres: ${freeCells}.`;
			}

			function updateCell(displayId, cellCode, newCarrinhoCode, cellDiv, inputElement, originalValue) {
				const requestBody = { displayId, cellCode, newCarrinhoCode };

				const spinner = document.createElement('div');
				spinner.className = 'cell-spinner';
				cellDiv.appendChild(spinner);
				inputElement.style.visibility = 'hidden';

				fetch('/api/displays/cells/update', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(requestBody)
				})
				.then(response => {
					return response.json().then(body => ({
						ok: response.ok,
						status: response.status,
						body: body
					})).catch(() => ({
						ok: false,
						status: response.status,
						body: { message: 'Não foi possível ler a resposta do servidor.' }
					}));
				})
				.then(result => {
					if (result.ok) {
						if (result.body.status === 'SUCCESS') {
							cellDiv.classList.add('update-success');
							if (newCarrinhoCode) {
								cellDiv.classList.add('occupied');
							} else {
								cellDiv.classList.remove('occupied');
							}
							inputElement.setAttribute('data-original-value', newCarrinhoCode);
							updateOccupancyCount();
						} else if (result.body.status === 'ALREADY_CHECKED') {
							cellDiv.classList.add('update-error');
							let alertMessage = result.body.message;
							if (result.body.currentDisplayCode && result.body.currentCellCode) {
								alertMessage = `Esta miniatura já está no expositor ${result.body.currentDisplayCode}, célula ${result.body.currentCellCode}.`;
							}
							Swal.fire('Aviso!', alertMessage, 'warning');
							inputElement.value = originalValue;
							if (originalValue) {
								cellDiv.classList.add('occupied');
							} else {
								cellDiv.classList.remove('occupied');
							}
							updateOccupancyCount();
						}
					} else {
						throw new Error(result.body.message || 'Ocorreu um erro desconhecido.');
					}
				})
				.catch(error => {
					console.error('Falha ao atualizar a célula:', error);
					inputElement.value = originalValue;
					cellDiv.classList.add('update-error');
					const errorMessage = error && error.message ? error.message : 'Não foi possível processar a sua requisição.';
					Swal.fire('Erro!', errorMessage, 'error');
				})
				.finally(() => {
					cellDiv.removeChild(spinner);
					inputElement.style.visibility = 'visible';
					setTimeout(() => {
						cellDiv.classList.remove('update-success', 'update-error');
					}, 1000);
				});
			}

			function renderAutocompleteResults(results, inputElement, cellDiv) {
				const existingResults = cellDiv.querySelector('.autocomplete-results');
				if (existingResults) { existingResults.remove(); }
				if (results.length === 0) { return; }

				const resultsContainer = document.createElement('div');
				resultsContainer.className = 'autocomplete-results';

				results.forEach(result => {
					const item = document.createElement('div');
					item.className = 'autocomplete-item';
					item.innerHTML = `<b>${result.codigo}</b> - ${result.descricao}`;
					item.addEventListener('mousedown', function() {
						inputElement.value = result.codigo;
						resultsContainer.remove();
						inputElement.blur();
					});
					resultsContainer.appendChild(item);
				});
				cellDiv.appendChild(resultsContainer);
			}

			function handleAutocomplete(event) {
				const input = event.target;
				const cellDiv = input.parentElement;
				const value = input.value;

				const existingResults = cellDiv.querySelector('.autocomplete-results');
				if (existingResults && !value) {
					existingResults.remove();
					return;
				}
				if (value.length < 2) { return; }

				fetch(`/carrinho/autocomplete/${value}`)
					.then(response => response.json())
					.then(data => {
						renderAutocompleteResults(data, input, cellDiv);
					});
			}

			function renderGrid(cells) {
				displayGridContainer.innerHTML = '';
				const grid = document.createElement('div');
				grid.className = 'grid-container';

				const cellMap = new Map(cells.map(cell => [cell.cellCode, cell]));
				const rows = "ABCDEFGHIJKLMNO".split('');
				const cols = [1, 2, 3, 4, 5];
				
				rows.forEach(row => {
					cols.forEach(col => {
						const cellCode = `${row}${col}`;
						const cellData = cellMap.get(cellCode);
						const cellDiv = document.createElement('div');
						cellDiv.className = 'grid-cell';
						
						const cellLabel = document.createElement('span');
						cellLabel.className = 'grid-cell-label';
						cellLabel.textContent = cellCode;
						cellDiv.appendChild(cellLabel);

						const input = document.createElement('input');
						input.type = 'text';
						input.id = `cellInput_${cellCode}`;
						input.setAttribute('data-cell-code', cellCode);
						input.maxLength = 10;

						if (cellData && cellData.carrinho) {
							input.value = cellData.carrinho.codigo;
							cellDiv.classList.add('occupied');
						} else {
							input.value = '';
						}

						input.addEventListener('focus', function() {
							cellDiv.classList.add('focused');
							input.setAttribute('data-original-value', input.value);
						});
						input.addEventListener('input', handleAutocomplete);
						input.addEventListener('blur', function() {
							cellDiv.classList.remove('focused');
							setTimeout(() => {
								const existingResults = cellDiv.querySelector('.autocomplete-results');
								if (existingResults) { existingResults.remove(); }
								
								const originalValue = input.getAttribute('data-original-value') || '';
								const newValue = input.value.trim().toUpperCase();

								if (originalValue.toUpperCase() !== newValue) {
									updateCell(currentDisplayId, cellCode, newValue, cellDiv, input, originalValue);
								}
							}, 150);
						});

						cellDiv.appendChild(input);
						grid.appendChild(cellDiv);
					});
				});

				displayGridContainer.appendChild(grid);
				updateOccupancyCount();
			}

			function renderDisplayButtons(displays) {
				displayButtonsContainer.innerHTML = '';
				const buttonGroup = document.createElement('div');
				buttonGroup.className = 'btn-group';

				displays.forEach(display => {
					const button = document.createElement('button');
					button.type = 'button';
					button.className = 'btn btn-default';
					button.textContent = display.displayCode;
					button.setAttribute('data-display-id', display.id);
					
					button.addEventListener('click', function() {
						const allButtons = displayButtonsContainer.querySelectorAll('button');
						allButtons.forEach(btn => {
							btn.classList.remove('btn-primary');
							btn.classList.add('btn-default');
						});
						this.classList.add('btn-primary');
						this.classList.remove('btn-default');
						
						fetchCells(display.id);
					});
					buttonGroup.appendChild(button);
				});
				displayButtonsContainer.appendChild(buttonGroup);
			}

			fetchDisplays();

			$('#logout-link').on('click', function(e) {
				e.preventDefault();
				$('#logout-form').submit();
			});
		});
	</script>
</body>
</html>
